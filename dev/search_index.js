var documenterSearchIndex = {"docs":
[{"location":"man/constructors/#Constructing-SpatialEcology-objects","page":"Creating objects","title":"Constructing SpatialEcology objects","text":"","category":"section"},{"location":"man/constructors/","page":"Creating objects","title":"Creating objects","text":"Pages = [\"constructors.md\"]","category":"page"},{"location":"man/constructors/","page":"Creating objects","title":"Creating objects","text":"Put texts here","category":"page"},{"location":"man/constructors/#Index","page":"Creating objects","title":"Index","text":"","category":"section"},{"location":"man/constructors/","page":"Creating objects","title":"Creating objects","text":"Pages = [\"constructors.md\"]","category":"page"},{"location":"man/constructors/#API","page":"Creating objects","title":"API","text":"","category":"section"},{"location":"man/constructors/","page":"Creating objects","title":"Creating objects","text":"Assemblage\nComMatrix\nSiteData","category":"page"},{"location":"man/constructors/#SpatialEcology.Assemblage","page":"Creating objects","title":"SpatialEcology.Assemblage","text":"Assemblage{D<:Real, P<:Locations}\n\n\n\n\n\n","category":"type"},{"location":"man/data/#Extracting-and-setting-data","page":"Getting and setting data","title":"Extracting and setting data","text":"","category":"section"},{"location":"man/data/","page":"Getting and setting data","title":"Getting and setting data","text":"Pages = [\"data.md\"]","category":"page"},{"location":"man/data/","page":"Getting and setting data","title":"Getting and setting data","text":"Put texts here","category":"page"},{"location":"man/data/#Index","page":"Getting and setting data","title":"Index","text":"","category":"section"},{"location":"man/data/","page":"Getting and setting data","title":"Getting and setting data","text":"Pages = [\"data.md\"]","category":"page"},{"location":"man/data/#API","page":"Getting and setting data","title":"API","text":"","category":"section"},{"location":"man/data/","page":"Getting and setting data","title":"Getting and setting data","text":"traits\nsitestats\nsitestatnames\ntraitnames\ncommatrix\n@with\n@traits\n@sitestats\naddtraits!\naddsitestats!\nsitetotals\nspeciestotals\ngetspecies\ngetsite","category":"page"},{"location":"man/data/#SpatialEcology.sitestats","page":"Getting and setting data","title":"SpatialEcology.sitestats","text":"sitestats(asm)\n\n\n\n\n\n","category":"function"},{"location":"man/data/#SpatialEcology.sitestatnames","page":"Getting and setting data","title":"SpatialEcology.sitestatnames","text":"sitestatnames(asm)\n\n\n\n\n\n","category":"function"},{"location":"man/data/#SpatialEcology.traitnames","page":"Getting and setting data","title":"SpatialEcology.traitnames","text":"traitnames(asm)\n\n\n\n\n\n","category":"function"},{"location":"man/data/#SpatialEcology.commatrix","page":"Getting and setting data","title":"SpatialEcology.commatrix","text":"commatrix(asm)\n\n\n\n\n\n","category":"function"},{"location":"man/data/#DataFramesMeta.@with","page":"Getting and setting data","title":"DataFramesMeta.@with","text":"@with(d, expr)\n\n@with allows DataFrame columns keys to be referenced as symbols.\n\nArguments\n\nd : an AbstractDataFrame type\nexpr : the expression to evaluate in d\n\nDetails\n\n@with works by parsing the expression body for all columns indicated by symbols (e.g. :colA). Then, a function is created that wraps the body and passes the columns as function arguments. This function is then called. Operations are efficient because:\n\nA pseudo-anonymous function is defined, so types are stable.\nColumns are passed as references, eliminating DataFrame indexing.\n\nThe following\n\n@with(d, :a .+ :b .+ 1)\n\nbecomes\n\ntempfun(a, b) = a .+ b .+ 1\ntempfun(d[!, :a], d[!, :b])\n\nIf an expression is wrapped in ^(expr), expr gets passed through untouched. If an expression is wrapped in  $(expr), the column is referenced by the variable expr rather than a symbol.\n\nIf the expression provide to @with begins with @byrow, the function created by the @with block is broadcasted along the columns of the data frame.\n\nExamples\n\njulia> using DataFramesMeta\n\njulia> y = 3;\n\njulia> df = DataFrame(x = 1:3, y = [2, 1, 2]);\n\njulia> x = [2, 1, 0];\n\njulia> @with(df, :y .+ 1)\n3-element Vector{Int64}:\n 3\n 2\n 3\n\njulia> @with(df, :x + x)\n3-element Vector{Int64}:\n 3\n 3\n 3\n\njulia> @with df begin\n            res = 0.0\n            for i in 1:length(:x)\n                res += :x[i] * :y[i]\n            end\n            res\n        end\n10.0\n\njulia> @with(df, df[:x .> 1, ^(:y)]) # The ^ means leave the :y alone\n2-element Vector{Int64}:\n 1\n 2\n\njulia> colref = :x;\n\njulia> @with(df, :y + $colref) # Equivalent to df[!, :y] + df[!, colref]\n3-element Vector{Int64}:\n 3\n 3\n 5\n\njulia> @with df @byrow :x * :y\n3-element Vector{Int64}:\n 2\n 2\n 6\n\n\nnote: Note\n@with creates a function, so the scope within @with is a local scope. Variables in the parent can be read. Writing to variables in the parent scope differs depending on the type of scope of the parent. If the parent scope is a global scope, then a variable cannot be assigned without using the global keyword. If the parent scope is a local scope (inside a function or let block for example), the global keyword is not needed to assign to that parent scope.\n\n\n\n\n\n","category":"macro"},{"location":"man/data/#SpatialEcology.@traits","page":"Getting and setting data","title":"SpatialEcology.@traits","text":"@traits(x, expr)\n\n\n\n\n\n","category":"macro"},{"location":"man/data/#SpatialEcology.@sitestats","page":"Getting and setting data","title":"SpatialEcology.@sitestats","text":"@sitestats(x, expr)\n\n\n\n\n\n","category":"macro"},{"location":"man/data/#SpatialEcology.addtraits!","page":"Getting and setting data","title":"SpatialEcology.addtraits!","text":"addtraits!(asm::Assemblage, newtraits::DataFrames.DataFrame, species::Symbol; validate = true, tolerance = 0.5, makeunique = false)\n\n\n\n\n\n","category":"function"},{"location":"man/data/#SpatialEcology.addsitestats!","page":"Getting and setting data","title":"SpatialEcology.addsitestats!","text":"addsitestats!(asm::Assemblage, newsites::DataFrames.DataFrame, sites::Symbol; validate = true, tolerance = 0.5, makeunique = false)\n\n\n\n\n\n","category":"function"},{"location":"man/data/#SpatialEcology.sitetotals","page":"Getting and setting data","title":"SpatialEcology.sitetotals","text":"sitetotals(com)\n\n\n\n\n\n","category":"function"},{"location":"man/data/#SpatialEcology.speciestotals","page":"Getting and setting data","title":"SpatialEcology.speciestotals","text":"speciestotals(com)\n\n\n\n\n\n","category":"function"},{"location":"man/data/#SpatialEcology.getspecies","page":"Getting and setting data","title":"SpatialEcology.getspecies","text":"getspecies(com)\n\n\n\n\n\n","category":"function"},{"location":"man/data/#SpatialEcology.getsite","page":"Getting and setting data","title":"SpatialEcology.getsite","text":"getsite(com)\n\n\n\n\n\n","category":"function"},{"location":"man/getters/#Working-with-objects","page":"Working with SpatialEcology objects","title":"Working with objects","text":"","category":"section"},{"location":"man/getters/","page":"Working with SpatialEcology objects","title":"Working with SpatialEcology objects","text":"Pages = [\"getters.md\"]","category":"page"},{"location":"man/getters/","page":"Working with SpatialEcology objects","title":"Working with SpatialEcology objects","text":"Put texts here","category":"page"},{"location":"man/getters/#Index","page":"Working with SpatialEcology objects","title":"Index","text":"","category":"section"},{"location":"man/getters/","page":"Working with SpatialEcology objects","title":"Working with SpatialEcology objects","text":"Pages = [\"getters.md\"]","category":"page"},{"location":"man/getters/#API","page":"Working with SpatialEcology objects","title":"API","text":"","category":"section"},{"location":"man/getters/","page":"Working with SpatialEcology objects","title":"Working with SpatialEcology objects","text":"nspecies\nnsites\noccupancy\nrichness\nnrecords\nsitenames\nspeciesnames\ncoordinates\noccurring\nnoccurring\noccupied\nnoccupied\noccurrences\ncooccurring","category":"page"},{"location":"man/getters/#SpatialEcology.nspecies","page":"Working with SpatialEcology objects","title":"SpatialEcology.nspecies","text":"nthings(com::AbstractComMatrix)\n\n\n\n\n\n","category":"function"},{"location":"man/getters/#SpatialEcology.nsites","page":"Working with SpatialEcology objects","title":"SpatialEcology.nsites","text":"nsites(com)\n\n\n\n\n\n","category":"function"},{"location":"man/getters/#EcoBase.occupancy","page":"Working with SpatialEcology objects","title":"EcoBase.occupancy","text":"occupancy(com::AbstractComMatrix)\n\n\n\n\n\n","category":"function"},{"location":"man/getters/#EcoBase.richness","page":"Working with SpatialEcology objects","title":"EcoBase.richness","text":"richness(com::AbstractComMatrix)\n\n\n\n\n\n","category":"function"},{"location":"man/getters/#EcoBase.nrecords","page":"Working with SpatialEcology objects","title":"EcoBase.nrecords","text":"nrecords(com)\n\n\n\n\n\n","category":"function"},{"location":"man/getters/#SpatialEcology.sitenames","page":"Working with SpatialEcology objects","title":"SpatialEcology.sitenames","text":"sitenames(com)\n\n\n\n\n\n","category":"function"},{"location":"man/getters/#SpatialEcology.speciesnames","page":"Working with SpatialEcology objects","title":"SpatialEcology.speciesnames","text":"speciesnames(com)\n\n\n\n\n\n","category":"function"},{"location":"man/getters/#EcoBase.coordinates","page":"Working with SpatialEcology objects","title":"EcoBase.coordinates","text":"coordinates(asm)\n\n\n\n\n\n","category":"function"},{"location":"man/getters/#EcoBase.occurring","page":"Working with SpatialEcology objects","title":"EcoBase.occurring","text":"occurring(com::AbstractComMatrix)\n\n\n\n\n\n","category":"function"},{"location":"man/getters/#EcoBase.occupied","page":"Working with SpatialEcology objects","title":"EcoBase.occupied","text":"occupied(com::AbstractComMatrix)\n\n\n\n\n\n","category":"function"},{"location":"man/getters/#EcoBase.occurrences","page":"Working with SpatialEcology objects","title":"EcoBase.occurrences","text":"occurrences(asm)\n\n\n\n\n\n","category":"function"},{"location":"man/randomization/#Randomization","page":"Randomizations","title":"Randomization","text":"","category":"section"},{"location":"man/randomization/","page":"Randomizations","title":"Randomizations","text":"Pages = [\"randomization.md\"]","category":"page"},{"location":"man/randomization/","page":"Randomizations","title":"Randomizations","text":"Put texts here","category":"page"},{"location":"man/randomization/#Index","page":"Randomizations","title":"Index","text":"","category":"section"},{"location":"man/randomization/","page":"Randomizations","title":"Randomizations","text":"Pages = [\"randomization.md\"]","category":"page"},{"location":"man/randomization/#API","page":"Randomizations","title":"API","text":"","category":"section"},{"location":"man/randomization/","page":"Randomizations","title":"Randomizations","text":"matrixrandomizer\nmatrixrandomizations","category":"page"},{"location":"man/randomization/#RandomBooleanMatrices.matrixrandomizer","page":"Randomizations","title":"RandomBooleanMatrices.matrixrandomizer","text":"matrixrandomizer(m [,rng]; method = curveball)\n\nCreate a matrix generator function that will return a random boolean matrix every time it is called, maintaining row and column sums. Non-boolean input matrix are interpreted as boolean, where values != 0 are true.\n\nExamples\n\n``` m = rand(0:4, 5, 6) rmg = matrixrandomizer(m)\n\nrandom1 = rand(rmg) random2 = rand(rmg) ``\n\n\n\n\n\n","category":"function"},{"location":"man/subsetting/#Groups-and-subsets","page":"Subsetting","title":"Groups and subsets","text":"","category":"section"},{"location":"man/subsetting/","page":"Subsetting","title":"Subsetting","text":"Pages = [\"subsetting.md\"]","category":"page"},{"location":"man/subsetting/","page":"Subsetting","title":"Subsetting","text":"One of the most powerful ideas in SpatialEcology is that it lets you create views into all objects (most importantly ComMatrix and Assemblage) based on a subset of species or sites.  The object will drop unused species or sites.","category":"page"},{"location":"man/subsetting/","page":"Subsetting","title":"Subsetting","text":"Let's say for instance we want to calculate the average range size for each latitudinal band  for the dataset of European amphibians.","category":"page"},{"location":"man/subsetting/","page":"Subsetting","title":"Subsetting","text":"First, we load the data:","category":"page"},{"location":"man/subsetting/","page":"Subsetting","title":"Subsetting","text":"using SpatialEcology, Plots, CSV, DataFrames, Statistics\nENV[\"GKSwstype\"]=\"nul\"\namphdata = CSV.read(joinpath(dirname(pathof(SpatialEcology)), \"..\", \"data\", \"amph_Europe.csv\"), DataFrame)\namph = Assemblage(amphdata[!, 4:end],amphdata[!, 1:3], sitecolumns = false);","category":"page"},{"location":"man/subsetting/","page":"Subsetting","title":"Subsetting","text":"And let's add the rangesizes of each species to the dataset","category":"page"},{"location":"man/subsetting/","page":"Subsetting","title":"Subsetting","text":"addtraits!(amph, occupancy(amph), :rangesize)","category":"page"},{"location":"man/subsetting/","page":"Subsetting","title":"Subsetting","text":"Then let's get all unique latitudes ","category":"page"},{"location":"man/subsetting/","page":"Subsetting","title":"Subsetting","text":"latitudes = unique(coordinates(amph)[:, 2])","category":"page"},{"location":"man/subsetting/","page":"Subsetting","title":"Subsetting","text":"We can use a simple to loop over all the latitudes, generate a relevant subset and calculate the mean rangesize","category":"page"},{"location":"man/subsetting/","page":"Subsetting","title":"Subsetting","text":"latitude_range = zeros(size(latitudes))\nfor (i, lat) in enumerate(latitudes)\n    sites = findall(==(lat), coordinates(amph)[:,2])\n    subset = view(amph, sites = sites)\n    latitude_range[i] = mean(subset[:rangesize])\nend\nscatter(latitudes, latitude_range, xlab = \"Latitude\", ylab = \"Mean range size\")","category":"page"},{"location":"man/subsetting/","page":"Subsetting","title":"Subsetting","text":"Subsetting and sampling over a factor is common enough that there is a specialized syntax  for this, groupspecies and groupsites.  All of the above can be expressed by grouping the assemblage over the second coordinate (latitude):","category":"page"},{"location":"man/subsetting/","page":"Subsetting","title":"Subsetting","text":"latitudinal_assemblages = groupsites(amph, coordinates(amph)[:,2], dropspecies = true)\nlatitude_range = [mean(lat[:rangesize]) for lat in latitudinal_assemblages]","category":"page"},{"location":"man/subsetting/","page":"Subsetting","title":"Subsetting","text":"You can also use subsetting to plot a single species:","category":"page"},{"location":"man/subsetting/","page":"Subsetting","title":"Subsetting","text":"spec = view(amph, species = [\"_Bufo_bufo\"])\nplot(spec, title = \"Common Toad\", showempty = true, c = cgrad([:grey, :red], categorical = true))","category":"page"},{"location":"man/subsetting/","page":"Subsetting","title":"Subsetting","text":"#Todo make this work without wrapping sp","category":"page"},{"location":"man/subsetting/","page":"Subsetting","title":"Subsetting","text":"Note that getindex ([]) will create a view by default - to create a new Assemblage object you can use copy.","category":"page"},{"location":"man/subsetting/#Index","page":"Subsetting","title":"Index","text":"","category":"section"},{"location":"man/subsetting/","page":"Subsetting","title":"Subsetting","text":"Pages = [\"subsetting.md\"]","category":"page"},{"location":"man/subsetting/#API","page":"Subsetting","title":"API","text":"","category":"section"},{"location":"man/subsetting/","page":"Subsetting","title":"Subsetting","text":"groupspecies\ngroupsites\naggregate","category":"page"},{"location":"man/subsetting/#SpatialEcology.groupspecies","page":"Subsetting","title":"SpatialEcology.groupspecies","text":"groupspecies(a::EcoBase.AbstractAssemblage, s::Symbol; kwargs...)\n\n\n\n\n\n","category":"function"},{"location":"man/subsetting/#SpatialEcology.groupsites","page":"Subsetting","title":"SpatialEcology.groupsites","text":"groupsites(a::EcoBase.AbstractAssemblage, s::Symbol; kwargs...)\n\n\n\n\n\n","category":"function"},{"location":"man/subsetting/#DataFrames.aggregate","page":"Subsetting","title":"DataFrames.aggregate","text":"aggregate(object, grid [, fun])\n\nAggregate object (either an Assemblage or Locations type) to grid. If object is an Assemblage{PointData} this will grid all points and return an Assemblage{GridData}. grid can be a GridTopology or a single Integer signifying the aggregation factor for already gridded data, the cellsize for point data. fun is an optional function specifying how to lump occurrences. If not specified the default function is any for Boolean Assemblages and sum for Integer ones.\n\n\n\n\n\n","category":"function"},{"location":"man/subsetting/#Utilities","page":"Subsetting","title":"Utilities","text":"","category":"section"},{"location":"man/subsetting/","page":"Subsetting","title":"Subsetting","text":"dispersionfield\npairwise\nasquantiles\nasquantiles!","category":"page"},{"location":"man/subsetting/#SpatialEcology.dispersionfield","page":"Subsetting","title":"SpatialEcology.dispersionfield","text":"dispersionfield(asm, site)\n\n\n\n\n\n","category":"function"},{"location":"man/subsetting/#StatsAPI.pairwise","page":"Subsetting","title":"StatsAPI.pairwise","text":"pairwise(f, x[, y];\n         symmetric::Bool=false, skipmissing::Symbol=:none)\n\nReturn a matrix holding the result of applying f to all possible pairs of entries in iterators x and y. Rows correspond to entries in x and columns to entries in y. If y is omitted then a square matrix crossing x with itself is returned.\n\nAs a special case, if f is cor, diagonal cells for which entries from x and y are identical (according to ===) are set to one even in the presence missing, NaN or Inf entries.\n\nKeyword arguments\n\nsymmetric::Bool=false: If true, f is only called to compute for the lower triangle of the matrix, and these values are copied to fill the upper triangle. Only allowed when y is omitted. Defaults to true when f is cor or cov.\nskipmissing::Symbol=:none: If :none (the default), missing values in inputs are passed to f without any modification. Use :pairwise to skip entries with a missing value in either of the two vectors passed to f for a given pair of vectors in x and y. Use :listwise to skip entries with a missing value in any of the vectors in x or y; note that this might drop a large part of entries. Only allowed when entries in x and y are vectors.\n\nExamples\n\njulia> using StatsBase, Statistics\n\njulia> x = [1 3 7\n            2 5 6\n            3 8 4\n            4 6 2];\n\njulia> pairwise(cor, eachcol(x))\n3×3 Matrix{Float64}:\n  1.0        0.744208  -0.989778\n  0.744208   1.0       -0.68605\n -0.989778  -0.68605    1.0\n\njulia> y = [1 3 missing\n            2 5 6\n            3 missing 2\n            4 6 2];\n\njulia> pairwise(cor, eachcol(y), skipmissing=:pairwise)\n3×3 Matrix{Float64}:\n  1.0        0.928571  -0.866025\n  0.928571   1.0       -1.0\n -0.866025  -1.0        1.0\n\n\n\n\n\npairwise(metric::PreMetric, a::AbstractMatrix, b::AbstractMatrix=a; dims)\n\nCompute distances between each pair of rows (if dims=1) or columns (if dims=2) in a and b according to distance metric. If a single matrix a is provided, compute distances between its rows or columns.\n\na and b must have the same numbers of columns if dims=1, or of rows if dims=2.\n\n\n\n\n\npairwise(metric::PreMetric, a, b=a)\n\nCompute distances between each element of collection a and each element of collection b according to distance metric. If a single iterable a is provided, compute distances between its elements.\n\n\n\n\n\n","category":"function"},{"location":"man/subsetting/#SpatialEcology.asquantiles","page":"Subsetting","title":"SpatialEcology.asquantiles","text":"asquantiles(x, n)\n\n\n\n\n\n","category":"function"},{"location":"man/subsetting/#SpatialEcology.asquantiles!","page":"Subsetting","title":"SpatialEcology.asquantiles!","text":"asquantiles!(x, n)\n\n\n\n\n\n","category":"function"},{"location":"lib/public/#Public-Documentation","page":"Library","title":"Public Documentation","text":"","category":"section"},{"location":"lib/public/","page":"Library","title":"Library","text":"Documentation for SpatialEcology.jl's public interface.","category":"page"},{"location":"#SpatialEcology.jl","page":"Home","title":"SpatialEcology.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Community- and macro-ecological analysis in julia","category":"page"},{"location":"#Package-Features","page":"Home","title":"Package Features","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Easily load macroecological and community ecological datasets\nEasy and cheap views allows analysis in a split-apply-combine framework\nPlots recipes for all objects\nCompatible with Diversity.jl via the EcoBase framework","category":"page"},{"location":"","page":"Home","title":"Home","text":"The Quick start provides a tutorial with a quick overview to get you started with SpatialEcology.","category":"page"},{"location":"","page":"Home","title":"Home","text":"The best way to see what the package can do is to work through some of the Example analyses using this package to recreate macroecological analyses from published papers.","category":"page"},{"location":"#Manual-Outline","page":"Home","title":"Manual Outline","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Pages = [\n    \"man/constructors.md\",\n    \"man/getters.md\",\n    \"man/data.md\",\n    \"man/subsetting.md\",\n    \"man/randomization.md\",\n    \"examples/nodebased.md\"\n]\nDepth = 1","category":"page"},{"location":"tutorial/#Getting-started:","page":"Tutorial / Quick start","title":"Getting started:","text":"","category":"section"},{"location":"tutorial/","page":"Tutorial / Quick start","title":"Tutorial / Quick start","text":"The aim of SpatialEcology is to make it easy to input species occurrence data, along with species traits and site attributes,  and do most analyses intuitively and simply. For this example we'll use a dataset of the distributions of all amphibians in Europe, based on a (previous) rasterization of IUCN's amphibian shapefile data onto a 0.5x0.5 lat-long grid (provided  with the package).","category":"page"},{"location":"tutorial/","page":"Tutorial / Quick start","title":"Tutorial / Quick start","text":"First, let's load the relevant libraries","category":"page"},{"location":"tutorial/","page":"Tutorial / Quick start","title":"Tutorial / Quick start","text":"using SpatialEcology, Plots, CSV, DataFrames, Statistics\nENV[\"GKSwstype\"]=\"nul\"","category":"page"},{"location":"tutorial/","page":"Tutorial / Quick start","title":"Tutorial / Quick start","text":"We read in the species occurrence data from a DataFrame. The object constructors take a wide range of input data types, a typical being a presence-absence matrix  as a DataFrame along with the spatial coordinates of sites as a 3-column DataFrame. In the example data, the site coordinates are simply the first three columns","category":"page"},{"location":"tutorial/","page":"Tutorial / Quick start","title":"Tutorial / Quick start","text":"amphdata = CSV.read(joinpath(dirname(pathof(SpatialEcology)), \"..\", \"data\", \"amph_Europe.csv\"), DataFrame);\namphdata[1:3,1:6]","category":"page"},{"location":"tutorial/","page":"Tutorial / Quick start","title":"Tutorial / Quick start","text":"We split the first three columns off the DataFrame and create an Assemblage object The sitecolumns keyword tells SpatialEcology that the input DataFrame has sites as rows (and species as columns)","category":"page"},{"location":"tutorial/","page":"Tutorial / Quick start","title":"Tutorial / Quick start","text":"amph = Assemblage(amphdata[!, 4:end],amphdata[!, 1:3], sitecolumns = false)","category":"page"},{"location":"tutorial/","page":"Tutorial / Quick start","title":"Tutorial / Quick start","text":"Plotting recipes are defined for Assemblage objects - here we can simply plot the entire object to get a richness map","category":"page"},{"location":"tutorial/","page":"Tutorial / Quick start","title":"Tutorial / Quick start","text":"plot(amph)","category":"page"},{"location":"tutorial/#Accessing-and-adding-data:","page":"Tutorial / Quick start","title":"Accessing and adding data:","text":"","category":"section"},{"location":"tutorial/","page":"Tutorial / Quick start","title":"Tutorial / Quick start","text":"Access functions summarize the data, such as occupancy, richness, nsites, nspecies","category":"page"},{"location":"tutorial/","page":"Tutorial / Quick start","title":"Tutorial / Quick start","text":"mean(occupancy(amph))","category":"page"},{"location":"tutorial/","page":"Tutorial / Quick start","title":"Tutorial / Quick start","text":"Add DataFrames or Vectors of data to the assemblage, DataFrames are automatically aligned keeping everything together. Access data by column name.","category":"page"},{"location":"tutorial/","page":"Tutorial / Quick start","title":"Tutorial / Quick start","text":"addtraits!(amph, occupancy(amph), :rangesize)\nhistogram(amph[:rangesize], grid = false, legend = false)","category":"page"},{"location":"tutorial/#Easy-subsetting-and-quick-views:","page":"Tutorial / Quick start","title":"Easy subsetting and quick views:","text":"","category":"section"},{"location":"tutorial/","page":"Tutorial / Quick start","title":"Tutorial / Quick start","text":"It is easy to do analyses by taking subsets of the objects and analyzing on them - i.e. the split-apply-combine strategy. Let's say we want to get the mean range of all species  occurring in each grid cell. We can map over all sites in the assemblage, and for each site use occurring to extract the indexes of the species that occur in that site. Finally we can use this to index into the rangesize column we added to the dataframe above, and  take the mean. A plot recipe allows us to create a heatmap for any numeric vector of values that match the sites in the Assemblage object.","category":"page"},{"location":"tutorial/","page":"Tutorial / Quick start","title":"Tutorial / Quick start","text":"meanrange = map(site->mean(amph[:rangesize][occurring(amph,site)]), 1:nsites(amph))\nplot(meanrange, amph, color = :fire)","category":"page"},{"location":"tutorial/","page":"Tutorial / Quick start","title":"Tutorial / Quick start","text":"The subsetting is fast as it uses views by default and allocate very little. You can also use view explicitly to get a handle on a subset of an Assemblage, subsetting by either a vector of species (to get a smaller taxonomic group) or a vector of sites (to get a smaller geographic area). Here we get the names of all species in the genus Triturus and use this to create a view that acts as a smaller Assemblage for this species alone.","category":"page"},{"location":"tutorial/","page":"Tutorial / Quick start","title":"Tutorial / Quick start","text":"triturus = view(amph, species = contains.(speciesnames(amph), \"Triturus\"))","category":"page"},{"location":"tutorial/","page":"Tutorial / Quick start","title":"Tutorial / Quick start","text":"We can then use this dataset for further analyses - here getting the latitudinal range for the genus in Europe:","category":"page"},{"location":"tutorial/","page":"Tutorial / Quick start","title":"Tutorial / Quick start","text":"extrema(coordinates(triturus)[:,1])","category":"page"},{"location":"tutorial/#Aggregation-and-other-operations","page":"Tutorial / Quick start","title":"Aggregation and other operations","text":"","category":"section"},{"location":"tutorial/","page":"Tutorial / Quick start","title":"Tutorial / Quick start","text":"For gridded Assemblages, you can also do some simple geographic operations on the object, such as aggregrating the grid to a coarser grain size. Here, we lump them to a 2 times coarser grain","category":"page"},{"location":"tutorial/","page":"Tutorial / Quick start","title":"Tutorial / Quick start","text":"amp2 = aggregate(amph, 2)\ndefault(color = cgrad(:Spectral, rev = true))\nplot(plot(amph), plot(amp2))","category":"page"},{"location":"tutorial/","page":"Tutorial / Quick start","title":"Tutorial / Quick start","text":"There are currently a few extra less generic operations defined on Assemblages, that may at some point be moved to a different module. For example, you can generate the  \"dispersion field\" of a given site using the dispersionfield function. A dispersion field of a site is a map of the total richness of all species occurring in a given site  Graves & Rahbek 2005 PNAS. This illustrates the compositional similarity of the site to it's surrounding sites. Here we plot the dispersion field for site number 50. ","category":"page"},{"location":"tutorial/","page":"Tutorial / Quick start","title":"Tutorial / Quick start","text":"plot(dispersionfield(amph, 50), amph, c = :rainbow)","category":"page"},{"location":"tutorial/","page":"Tutorial / Quick start","title":"Tutorial / Quick start","text":"This functionality of the SpatialEcology package was used for the analyses in Borregaard, Graves & Rahbek, 2020.","category":"page"},{"location":"examples/nodebased/","page":"Node-based analysis of species distributions","title":"Node-based analysis of species distributions","text":"This example demonstrates how to do a node-based comparison of species distributions, as described in Borregaard, M.K., Rahbek, C., Fjeldså, J., Parra, J.L., Whittaker, R.J. and Graham, C.H. (2014). Node-based analysis of species distributions. Methods in Ecology and Evolution 5: 1225-1235.  It demonstrates the whole process of loading the data and developing the method,  as a case study example.","category":"page"},{"location":"examples/nodebased/#Load-data-and-create-objects","page":"Node-based analysis of species distributions","title":"Load data and create objects","text":"","category":"section"},{"location":"examples/nodebased/","page":"Node-based analysis of species distributions","title":"Node-based analysis of species distributions","text":"First, let's load the data. We have the data in two DataFrames, one of species occurrences in each grid cell, and one with the lat-long coordinates of each  grid cell. The DataFrame of occurrences is in the widely used phylocom format,  which is a long-form format for associating the occurrence of species in sites.  It consists of three columns, a column of species names, one of abundances  (here 1, as it's a presence-absence data set) and a column of sites. ","category":"page"},{"location":"examples/nodebased/","page":"Node-based analysis of species distributions","title":"Node-based analysis of species distributions","text":"using CSV, DataFrames, SpatialEcology\nphylocom = CSV.read(\"../../data/tyrann_phylocom.tsv\", DataFrame)","category":"page"},{"location":"examples/nodebased/","page":"Node-based analysis of species distributions","title":"Node-based analysis of species distributions","text":"The coordinates is a simple DataFrame with a column of sites, one of latitude  and one of longitude","category":"page"},{"location":"examples/nodebased/","page":"Node-based analysis of species distributions","title":"Node-based analysis of species distributions","text":"coord = CSV.read(\"../../data/tyrann_coords.tsv\", DataFrame)","category":"page"},{"location":"examples/nodebased/","page":"Node-based analysis of species distributions","title":"Node-based analysis of species distributions","text":"We ensure that the column of sites are represented as strings in both data  sets. We then construct the Assemblage object. The site columns are used to  match the two DataFrames together.","category":"page"},{"location":"examples/nodebased/","page":"Node-based analysis of species distributions","title":"Node-based analysis of species distributions","text":"phylocom.Plot = string.(phylocom.Plot)\ncoord.cell = string.(coord.cell)\ntyrants = Assemblage(phylocom, coord)","category":"page"},{"location":"examples/nodebased/","page":"Node-based analysis of species distributions","title":"Node-based analysis of species distributions","text":"Let's have a look at the data","category":"page"},{"location":"examples/nodebased/","page":"Node-based analysis of species distributions","title":"Node-based analysis of species distributions","text":"using Plots\nENV[\"GKSwstype\"]=\"nul\" # this is just for the docs to run remotely\ndefault(color = cgrad(:Spectral, rev = true))\nplot(tyrants, size = (600, 800))","category":"page"},{"location":"examples/nodebased/","page":"Node-based analysis of species distributions","title":"Node-based analysis of species distributions","text":"Next, we'll read in the phylogenetic tree","category":"page"},{"location":"examples/nodebased/","page":"Node-based analysis of species distributions","title":"Node-based analysis of species distributions","text":"using Phylo \ntree = open(parsenewick, \"../../data/tyrannid_tree.tre\")\nsort!(tree) # sort the nodes on the tree in order of size - useful for plotting\nplot(tree, treetype = :fan)","category":"page"},{"location":"examples/nodebased/#Extract-information-from-a-single-clade","page":"Node-based analysis of species distributions","title":"Extract information from a single clade","text":"","category":"section"},{"location":"examples/nodebased/","page":"Node-based analysis of species distributions","title":"Node-based analysis of species distributions","text":"The Phylo package uses iterators over  vertices in the phylogeny for almost everything. For example, to get a vector of all internal (non-tip) nodes in the phylogeny, we would create an iterator over the names of all nodes in the tree, filtered by the function isleaf, which checks whether a node has any descendants, and then collect the iterator to a vector","category":"page"},{"location":"examples/nodebased/","page":"Node-based analysis of species distributions","title":"Node-based analysis of species distributions","text":"nodes = nodenamefilter(!isleaf, tree)\nnodevec = collect(nodes)","category":"page"},{"location":"examples/nodebased/","page":"Node-based analysis of species distributions","title":"Node-based analysis of species distributions","text":"Let's pick a random node from the vector to demonstrate how we can get information on that node","category":"page"},{"location":"examples/nodebased/","page":"Node-based analysis of species distributions","title":"Node-based analysis of species distributions","text":"randnode = nodevec[131]","category":"page"},{"location":"examples/nodebased/","page":"Node-based analysis of species distributions","title":"Node-based analysis of species distributions","text":"We can get a list of the names of all tips/species descending from the node by getting all descendant nodes with getdescendants and filtering with isleaf.  We need to pass an anonymous function to filter here, because the isleaf function takes two arguments.","category":"page"},{"location":"examples/nodebased/","page":"Node-based analysis of species distributions","title":"Node-based analysis of species distributions","text":"nodespecies(tree, node) = filter(x -> isleaf(tree, x), getdescendants(tree, node))\nnodespecies(tree, randnode)","category":"page"},{"location":"examples/nodebased/","page":"Node-based analysis of species distributions","title":"Node-based analysis of species distributions","text":"We can use that species list to subset an Assemblage object. For instance, we can make a function to create a smaller Assemblage of all species descending from our selected node. ","category":"page"},{"location":"examples/nodebased/","page":"Node-based analysis of species distributions","title":"Node-based analysis of species distributions","text":"function get_clade(assemblage, tree, node)\n    specs = nodespecies(tree, node)\n    view(assemblage, species = specs)\nend\n\nrand_clade = get_clade(tyrants, tree, randnode)\nplot(rand_clade)","category":"page"},{"location":"examples/nodebased/#Comparing-the-richness-of-sister-clades","page":"Node-based analysis of species distributions","title":"Comparing the richness of sister clades","text":"","category":"section"},{"location":"examples/nodebased/","page":"Node-based analysis of species distributions","title":"Node-based analysis of species distributions","text":"The question we are interested in addressing here is: At a given node where the lineage splits into two sister clades - are the two descendant clades distributed differently? This could be an indication that an evolutionary or biogeographic event happened at that time, of consequence for the current distribution of  the species. So let's get the two descendant clades, and plot their distribution in comparison to the parent clade","category":"page"},{"location":"examples/nodebased/","page":"Node-based analysis of species distributions","title":"Node-based analysis of species distributions","text":"function plot_node(assemblage, tree, node)\n    ch1, ch2 = getchildren(tree, node)[1:2]\n    assm = get_clade(assemblage, tree, node)\n    assmch1 = get_clade(assm, tree, ch1)\n    assmch2 = get_clade(assm, tree, ch2)\n\n    plot(\n        plot(assm), plot(assmch1), plot(assmch2),\n        layout = (1,3), size = (1200, 400), title = [\"parent\" \"child 1\" \"child 2\"]\n    )\nend\n\nplot_node(tyrants, tree, randnode)","category":"page"},{"location":"examples/nodebased/","page":"Node-based analysis of species distributions","title":"Node-based analysis of species distributions","text":"It is clear that the two clades have distinct distributions, with the first descendant appearing to be overrepresented in the tropical rainforest biome, mainly in the Amazon. But is the difference great enough that we can say that  this is not just a random pattern? We can use randomization to find out.","category":"page"},{"location":"examples/nodebased/#Using-randomization-to-assess-significance-of-distribution-differences","page":"Node-based analysis of species distributions","title":"Using randomization to assess significance of distribution differences","text":"","category":"section"},{"location":"examples/nodebased/","page":"Node-based analysis of species distributions","title":"Node-based analysis of species distributions","text":"SpatialEcology Assemblages can be randomized using the curveball matrix randomization algorithm defined in RandomBooleanMatrices.jl. This algorithm randomizes a species-by-site matrix while keeping row and column sums constant, and is very fast. We can instantiate a matrixrandomizer object from our assemblage, and then use this object to repeatedly generate randomized communities","category":"page"},{"location":"examples/nodebased/","page":"Node-based analysis of species distributions","title":"Node-based analysis of species distributions","text":"rmg = matrixrandomizer(rand_clade)\nnewcomm = rand(rmg)\nplot(newcomm)","category":"page"},{"location":"examples/nodebased/","page":"Node-based analysis of species distributions","title":"Node-based analysis of species distributions","text":"Because row and column sums are kept constant, the richness of the randomized community is the same. But the richness of the two descendant clades will be different - let's look at our focal node","category":"page"},{"location":"examples/nodebased/","page":"Node-based analysis of species distributions","title":"Node-based analysis of species distributions","text":"ch1, ch2 = getchildren(tree, randnode)[1:2]\nrandch1 = get_clade(newcomm, tree, ch1)\nrandch2 = get_clade(newcomm, tree, ch2)\nplot(\n    plot(rand_clade), plot(randch1), plot(randch2),\n    layout = (1,3), size = (1200, 400)\n)","category":"page"},{"location":"examples/nodebased/","page":"Node-based analysis of species distributions","title":"Node-based analysis of species distributions","text":"This represents a random expectation for the species richness of the two descendant clades should be. We can repeat this process 100 times and store the species richness of one of the clades in order to get a sampling distribution. The mean and standard deviation of this distribution can be used to assess how unexpected our empirically observed distribution is. We will focus just on one of the descendants, child clade ch2. The pattern for the other descendant is mirrored.","category":"page"},{"location":"examples/nodebased/","page":"Node-based analysis of species distributions","title":"Node-based analysis of species distributions","text":"using Random: rand!\nfunction simulate_descendants(clade, tree, descendant; nsims = 99)\n    rmg = matrixrandomizer(clade)\n    ret = zeros(nsims + 1, nsites(clade))  # a matrix to hold the richness values from the simulations\n    ret[1, :] = richness(get_clade(clade, tree, descendant))\n    for i in 2:nsims + 1\n        ret[i, :] .= richness(get_clade(rand!(rmg), tree, descendant))\n    end\n    ret\nend\n\nsims = simulate_descendants(rand_clade, tree, ch2)","category":"page"},{"location":"examples/nodebased/","page":"Node-based analysis of species distributions","title":"Node-based analysis of species distributions","text":"Then we calculate the mean and standard deviation across simulations and use this to express the empirical richness values as standardized effect sizes.","category":"page"},{"location":"examples/nodebased/","page":"Node-based analysis of species distributions","title":"Node-based analysis of species distributions","text":"using Statistics\nfunction calculate_SOS(sims)\n    sd = std.(eachcol(sims))\n    me = mean.(eachcol(sims))\n    (sims[1, :] .- me) ./ sd\nend","category":"page"},{"location":"examples/nodebased/","page":"Node-based analysis of species distributions","title":"Node-based analysis of species distributions","text":"The resulting standardized effect size for each grid cell constitutes the SOS metric of Borregaard et al. (2014). To calculate this for our focal cell and plot it we can do","category":"page"},{"location":"examples/nodebased/","page":"Node-based analysis of species distributions","title":"Node-based analysis of species distributions","text":"sims = simulate_descendants(rand_clade, tree, ch1)\nSOS = calculate_SOS(sims)\nplot(SOS, rand_clade, clim = (-8,8), fillcolor = :RdYlBu)","category":"page"},{"location":"examples/nodebased/","page":"Node-based analysis of species distributions","title":"Node-based analysis of species distributions","text":"We see a clear distinction between the two clades descending from our focal node, where one descendant is overrepresented in tropical moist forest and the other in colder regions.","category":"page"},{"location":"examples/nodebased/","page":"Node-based analysis of species distributions","title":"Node-based analysis of species distributions","text":"The strength of divergence among the two clades is summarized by the GND value (Borregaard et al. 2014)","category":"page"},{"location":"examples/nodebased/","page":"Node-based analysis of species distributions","title":"Node-based analysis of species distributions","text":"using StatsBase: tiedrank\n\nfunction calculate_GND(sims)\n  # two internal convenience functions\n  logit(p) = log(p/(1-p))\n  invlogit(p) = exp(p)/(1+exp(p))\n\n  n = size(sims, 1)\n  r = [tiedrank(x)[1]/(n + 1) for x in eachcol(sims)]\n  \n  p = 1 .- 2 .* abs.(r .- 0.5) .- 1/n\n  α = mean(logit.(p))\n  1-invlogit(α)\nend\n\nGND = calculate_GND(sims)","category":"page"},{"location":"examples/nodebased/#Applying-the-method-to-the-entire-phylogeny","page":"Node-based analysis of species distributions","title":"Applying the method to the entire phylogeny","text":"","category":"section"},{"location":"examples/nodebased/","page":"Node-based analysis of species distributions","title":"Node-based analysis of species distributions","text":"We can use all of the above to go through the entire phylogeny and generate SOS and GND values. First, let us create a function that calculates both metrics","category":"page"},{"location":"examples/nodebased/","page":"Node-based analysis of species distributions","title":"Node-based analysis of species distributions","text":"function process_node(assemblage, tree, nodename; nsims = 100)\n    clade = get_clade(assemblage, tree, nodename)\n    children = getchildren(tree, nodename)\n\n    if length(children) != 2 || any(x -> isleaf(tree, x) || nspecies(get_clade(assemblage, tree, x)) < 4, children)    \n        return (fill(NaN, nsites(clade)), NaN)\n    end\n    \n    sims = simulate_descendants(clade, tree, children[1]; nsims)\n    calculate_SOS(sims), calculate_GND(sims)\nend\n\nSOS, GND = process_node(tyrants, tree, randnode)\nplot(SOS, tyrants, clim = (-8,8), fillcolor = :RdYlBu)","category":"page"},{"location":"examples/nodebased/","page":"Node-based analysis of species distributions","title":"Node-based analysis of species distributions","text":"Finally, we go through every node on the true and calculate the metrics for them","category":"page"},{"location":"examples/nodebased/","page":"Node-based analysis of species distributions","title":"Node-based analysis of species distributions","text":"using ProgressLogging\nfunction node_based_analysis(assemblage::Assemblage, tree::AbstractTree)\n   nodevec = collect(nodenamefilter(!isleaf, tree))\n   SOSs = Matrix{Float64}(undef, nsites(tyrants), length(nodevec))\n   GNDs = Vector{Float64}(undef, length(nodevec))\n   @progress for (i, node) in enumerate(nodevec)\n        println(i)\n       SOSs[:,i], GNDs[i] = process_node(tyrants, tree, node)\n   end\n   SOSs, GNDs\nend\n\nSOSs, GNDs = node_based_analysis(tyrants, tree)","category":"page"},{"location":"examples/nodebased/","page":"Node-based analysis of species distributions","title":"Node-based analysis of species distributions","text":"Let's visualize the GND values on the tree","category":"page"},{"location":"examples/nodebased/","page":"Node-based analysis of species distributions","title":"Node-based analysis of species distributions","text":"plot(tree, showtips = false, marker_z = GNDs, color = cgrad(:YlOrRd, 10, categorical = true))","category":"page"},{"location":"examples/nodebased/","page":"Node-based analysis of species distributions","title":"Node-based analysis of species distributions","text":"We notice that a few of the nodes stand clearly out with significant distributional changes","category":"page"}]
}
